# Database Conventions

> **AI Agent Instruction**: Follow these database conventions when creating entities and queries.

---

## ⚠️ IMPORTANT: Migration Strategy

### Current Setup: **JPA Auto-Update (No Migration Files)**

```properties
# application-dev.properties
spring.jpa.hibernate.ddl-auto=update
```

> [!IMPORTANT]
> **This project does NOT use Flyway or Liquibase migrations.**
> Database schema is automatically generated and updated by JPA/Hibernate based on Entity classes.

### Development Workflow

```
✅ DO: Create/modify Entity classes
✅ DO: Use JPA annotations (@Entity, @Table, @Column)
✅ DO: Let Hibernate auto-generate schema

❌ DON'T: Create SQL migration files (V*.sql)
❌ DON'T: Manually write DDL scripts
```

---

## 1. Naming Conventions

### Tables

| Element | Convention | Example |
|---------|------------|---------|
| **Table Name** | snake_case, singular | `waste_reports`, `task_assignments` |
| **Junction Table** | `{table1}_{table2}` or meaningful name | `task_assignments` (Task-Collector) |
| **Column Name** | snake_case | `estimated_weight_kg`, `service_area_id` |
| **Primary Key** | `{entity}_id` (UUID) | `user_id`, `task_id`, `report_id` |
| **Foreign Key** | `{referenced_entity}_id` | `user_id`, `service_area_id` |
| **Index** | Auto-generated by JPA | `@Index` annotation |
| **Unique Constraint** | `@UniqueConstraint` | In `@Table` annotation |

> [!NOTE]
> **Actual Schema**: The real database schema is defined by Entity classes in `features/*/entity/` folders.
> The templates below are examples only. Always check actual Entity classes for current schema.

---

## 2. Data Types Standards

### JPA to PostgreSQL Mapping

| Java Type | PostgreSQL | JPA Annotation |
|-----------|------------|----------------|
| **UUID** | `UUID` | `@Id @GeneratedValue(generator = "UUID")` |
| **String** | `VARCHAR(n)` / `TEXT` | `@Column(length = n)` or `columnDefinition = "TEXT"` |
| **Integer** | `INTEGER` | `@Column` |
| **Double** | `DOUBLE PRECISION` | `@Column` |
| **BigDecimal** | `NUMERIC` | `@Column(precision = p, scale = s)` |
| **LocalDateTime** | `TIMESTAMP` | `@Column` |
| **Instant** | `TIMESTAMPTZ` | `@Column` |
| **Enum** | `VARCHAR(50)` | `@Enumerated(EnumType.STRING)` |
| **Boolean** | `BOOLEAN` | `@Column` |

---

## 3. Entity Template (Actual Project Pattern)

### Standard Entity Structure

```java
@Entity
@Table(name = "waste_reports")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class WasteReport {

    @Id
    @GeneratedValue(generator = "UUID")
    @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator")
    @Column(name = "report_id", updatable = false, nullable = false)
    private UUID reportId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reporter_user_id", nullable = false)
    private User reporterUser;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "service_area_id")
    private ServiceArea serviceArea;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "waste_type_id")
    private WasteType wasteType;

    @Column(name = "description", columnDefinition = "TEXT")
    private String description;

    @Column(name = "latitude")
    private Double latitude;

    @Column(name = "longitude")
    private Double longitude;

    @Column(name = "report_photo_url")
    private String reportPhotoUrl;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", length = 50)
    private WasteReportStatus status;

    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private Instant createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private Instant updatedAt;
}
```

### Key Patterns

1. **Primary Keys**: Use UUID with `@GeneratedValue(generator = "UUID")`
2. **Timestamps**: Use `@CreationTimestamp` and `@UpdateTimestamp`
3. **Enums**: Use `@Enumerated(EnumType.STRING)`
4. **Relationships**: Use `FetchType.LAZY` for performance
5. **Lombok**: Use `@Data`, `@Builder`, `@NoArgsConstructor`, `@AllArgsConstructor`

---

## 4. Status Enums (Actual Project)

### WasteReportStatus
```java
public enum WasteReportStatus {
    PENDING,
    ASSIGNED,
    IN_PROGRESS,
    COMPLETED,
    CANCELLED
}
```

### TaskStatus
```java
public enum TaskStatus {
    PENDING,
    ASSIGNED,
    IN_PROGRESS,
    COMPLETED,
    CANCELLED
}
```

### TaskAssignmentStatus
```java
public enum TaskAssignmentStatus {
    PENDING,
    ACCEPTED,
    REJECTED,
    IN_PROGRESS,
    COMPLETED,
    CANCELLED
}
```

### ComplaintStatus
```java
public enum ComplaintStatus {
    OPEN,
    INVESTIGATING,
    RESOLVED,
    REJECTED
}
```

---

## 5. Relationship Patterns

### One-to-Many
```java
// Parent side (User has many WasteReports)
@OneToMany(mappedBy = "reporterUser", cascade = CascadeType.ALL)
private List<WasteReport> wasteReports;

// Child side (WasteReport belongs to User)
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "reporter_user_id", nullable = false)
private User reporterUser;
```

### Many-to-One
```java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "enterprise_user_id", nullable = false)
private User enterpriseUser;
```

### One-to-One
```java
@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "user_id", nullable = false)
private User user;
```

---

## 6. Index and Constraint Annotations

### Unique Constraints
```java
@Table(name = "enterprise_capabilities", 
    uniqueConstraints = {
        @UniqueConstraint(columnNames = {
            "enterprise_user_id", 
            "waste_type_id", 
            "service_area_id"
        })
    }
)
```

### Indexes
```java
@Table(name = "waste_reports",
    indexes = {
        @Index(name = "idx_waste_report_status", columnList = "status"),
        @Index(name = "idx_waste_report_area", columnList = "service_area_id")
    }
)
```

---

## 7. Soft Delete Pattern

```java
@Column(name = "deleted_at")
private Instant deletedAt;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "deleted_by_user_id")
private User deletedByUser;

// In Repository
@Query("SELECT e FROM Entity e WHERE e.deletedAt IS NULL")
List<Entity> findAllActive();
```

---

## 8. Audit Fields Pattern

```java
@Column(name = "created_at", nullable = false, updatable = false)
@CreationTimestamp
private Instant createdAt;

@Column(name = "updated_at")
@UpdateTimestamp
private Instant updatedAt;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "created_by_user_id")
private User createdByUser;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "updated_by_user_id")
private User updatedByUser;
```

---

## 9. Important Notes

> [!WARNING]
> **Schema Differences**: The actual database schema may differ from documentation templates.
> Always refer to Entity classes in `src/main/java/com/example/backendservice/features/*/entity/` for the source of truth.

> [!TIP]
> **Schema Inspection**: Use these commands to inspect actual database schema:
> ```sql
> -- List all tables
> \dt
> 
> -- Describe table structure
> \d table_name
> 
> -- View all columns
> SELECT column_name, data_type FROM information_schema.columns 
> WHERE table_name = 'your_table';
> ```

---

## 10. Development Best Practices

### When Creating New Entities

1. ✅ Create Entity class with proper annotations
2. ✅ Define relationships carefully (LAZY fetch)
3. ✅ Add audit fields (createdAt, updatedAt)
4. ✅ Use appropriate data types
5. ✅ Add indexes for frequently queried columns
6. ✅ Test entity creation and relationships
7. ✅ Let Hibernate auto-update the schema

### When Modifying Entities

1. ⚠️ Be careful with column renames (data loss risk)
2. ⚠️ Test in dev environment first
3. ⚠️ Consider data migration if needed
4. ⚠️ Backup production data before schema changes

